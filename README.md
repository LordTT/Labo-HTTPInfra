# Labo-HTTPInfra
Repo for the HTTPInfra lab

## Part1

### Demo

To build and run the docker image for part one yon need to go in the `docker-images\apache-php-image` folder and run the commands:

        docker build -t res/apache_php .
        docker run -d -p 9090:80 res/apache_php
        
You will then be able to see your website at the address `localhost:9090`.

### Dockerfile

In the Dockerfile we will first create the image based on the `php:7.2-apache` image and then copy the files for the host folder `/content` to the container folder `/var/www/html/`.

### Config files

You can get to the config files of the running image by running the command `docker exec -it YOU_CONTAINER_NAME /bin/bash`.

To find you container name you can use the `docker ps` command. 

Then navigate to the folder cointining the config files usind `cd /etc/apache2/`.

### Config

In our configuration the virtual host listens on the 80 port that will be forwarded to the port 9090 thanks to Docker.

The html content will be found int he `/var/www/html` folder.

## Part2

### Demo

To build and run the docker image for part one yon need to go in the `docker-images\express-image` folder and run the commands:

        docker build -t res/express_students .
        docker run -d -p 9090:3000 res/express_students
        
You will then be able to see the content randomly generated by the node.js script at the address `localhost:9090`.

### Dockerfile

In the Dockerfile we will first create the image based on the `node:14.17` image and then copy the files for the host folder `/src` to the container folder `/opt/app`. It will then run the script located at `/opt/app/index.js` using node

### Config files


### Config

## Part 3

### Demo

First thing to do is to start the two previous containers:  
1. `docker run -d --name apache_static res/apache_php`
1. `docker run -d --name express_dynamic res/express_students`

Next step is to get their ip address:
1. `docker inspect apache_php | grep -i ipaddres`
1. `docker inspect express_dynamic | grep -i ipaddres`

Once you've got the two ip addresses we need to update the file `conf/sites-available/001-reverse-proxy.conf` with the ip addresses from the previous step.

Now we can build and run the reverse proxy container:
1. `docker build -t res/apache_rp .`
1. `docker run -d -p 8080:80 res/apache_rp`

To test the routing the following steps need to work:  
1. accessing via `http://localhost:8080` should not work with a 403 error
1. accessing via `http://localhost:8080` and specifying the header host = demo.res.ch (or by adding the line `localhost demo.res.ch` inside hosts file and accessing through `http://demo.res.ch:8080`) should show a web page from static container
1. accessing via `http://localhost:8080/api/students/` with host=demo.res.ch should show a page with json data from dynamic container

### Dockerfile
In the Dockerfile we will first create the image based on the `php:7.2-apache` image and then copy the files for the host folder `./conf` to the container folder `/etc/apache2`.

Next step is to enable the apache modules that allow reverse proxy `proxy` and `proxy_http`

After that we enable the sites from the conf directory

### Why static configuration is fragile
The ip addresses from containers are dynamicaly assigned. It means that it will possibly not work at the next time we run all the containers as they may have changed their ip addresses.

### Why servers cannot be reached directly
First of all that's only true for non Linux OS. On Linux we can access each container without port mapping via their ip addres `ping <container_ip>` will work.

For other OS than Linux docker creates a Linux vm to run the containers which makes them unreachable from outside the vm we can still access them by doing a port mapping. You can simply `ping <container_ip>` and it will not work.

## Part 4

### Demo
As we have made change on the website files we need to rebuild the image `res/apache_php`.
Launch all containers like in [Part 3](#part-3) and access `http://demo.res.ch:8080` on your browser. Now you should see message from aliens that are auto updated each 10 seconds.

### Prove that request are send by the browser
Here we can see all the request send by the browser to our api:
![send request](./pictures/send_request_ajax.png)
On the left side we can see the requests and on the right side we see the response from the selected request.

### Why it would not work without reverse proxy
If we were not using a reverse proxy the browser would block any request that tries to access data from a different top level domain (anything that comes from another domain than res.ch) due to the cross origin policy.

### Configuration
For this step we only changed content files.

## Part 5

### Demo
On Linux execute the script `run_everything.sh`.

On windows execute the following commands:
- run static `docker run -d --name apache_static res/apache_php`
- run dynamic `docker run -d --name express_dynamic res/express_students`
- get ip from static `docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' apache_static`
- get ip from dynamic `docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' express_dynamic`
- run reverse proxy replace with the ip from previous steps `docker run -d -e STATIC_APP=<ip_static> -e DYNAMIC_APP=<ip_dynamic>:3000 -p 8080:80 res/apache_rp`

### Configuration

#### Dockerfile
Same as on [Part 3](#part-3) we just removed de enable site of `001-reverse-proxy.conf` because it will be auto generated by the php script.
We also copy the files `apache2-foreground` and `config-template.php`

#### apache2-foreground
This file is executed by the php:7.2-apache image so we added code here to execute a php script `config-template.php` and enable de site `001-reverse-proxy.conf`

### config-template.php
This is a php script that creates the file `001-reverse-proxy.conf` containing the values from environment variables.